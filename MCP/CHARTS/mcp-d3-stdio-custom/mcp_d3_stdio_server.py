#!/usr/bin/env python3
"""
Simple STDIO MCP-like server that accepts JSON tool calls on stdin and writes JSON responses to stdout.
Saves generated HTML files to ./html-charts and returns the path in the tool response.

Supported D3 chart types (overview):

1) Basic statistical charts
 - bar (vertical):    data: [{category:'A', value:30}, ...] OR normalized {'labels':[...], 'datasets':[{'data':[...]}]}
 - horizontal_bar:    same as bar, x/y swapped
 - grouped_bar:       nested groups: [{group:'G', values:[{label:'Q1',value:10}, ...]}]
 - stacked_bar:       trellis/stack using d3.stack(); input like {labels:[...], datasets:[{data:[...]}]}
 - line / area:       timeseries: [{date:'2025-01-01', value:123}, ...] (d3.scaleTime)
 - scatter:           [{x:10,y:20}, ...]
 - bubble:            [{x:10,y:20,r:5}, ...]

2) Distribution
 - histogram:         numeric array [10,20,30,...]
 - boxplot / violin:  grouped numeric arrays (implementations minimal; may require extra math)

3) Pie / circular
 - pie / donut:       [{label:'A', value:30}, ...]
 - radial bar / gauge: single value or small array

4) Hierarchical
 - tree / dendrogram: d3.hierarchy({name:'root', children:[...]})
 - treemap:           d3.treemap() hierarchical JSON with 'value' fields
 - circle packing:    d3.pack() (packed / proportional area) - expects items [{id,label,value,color}]
 - sunburst / partition: d3.partition() hierarchical JSON

5) Network & relationship
 - force-directed:    {nodes:[{id:...}], links:[{source:..., target:...}]}
 - chord:             adjacency matrix (placeholder)
 - sankey:            use d3-sankey plugin (placeholder)

6) Geospatial
 - choropleth / bubble map: requires GeoJSON + per-feature values (placeholder)

7) Specialized
 - calendar heatmap, radar, bullet, parallel coordinates, streamgraph (placeholders / minimal)

This file contains compact D3 templates for several charts and placeholders for more complex ones.
Each script_* function expects a JS variable name for data replacement (we inject JSON into `__DATA_VAR__`).

If a chart type is unrecognized, the server falls back to a line chart. To explicitly request a D3 variant, call the tool with chart_type hint (e.g. {"chart_type":"packed"}).
"""
from __future__ import annotations
import sys
import json
import os
from pathlib import Path
from datetime import datetime
import hashlib
import html
import traceback
import re
from chart_renderer import render_chart_html_from_dataset, extract_json_from_text

ROOT = Path(__file__).resolve().parent
OUTDIR = ROOT / 'html-charts'
OUTDIR.mkdir(parents=True, exist_ok=True)

# Load external resources and prompts if available
RESOURCES_FILE = ROOT / 'resources' / 'chart_resources.txt'
PROMPTS_FILE = ROOT / 'prompts' / 'chart_prompts.txt'

resources_text = RESOURCES_FILE.read_text(encoding='utf-8') if RESOURCES_FILE.exists() else ''
prompts_text = PROMPTS_FILE.read_text(encoding='utf-8') if PROMPTS_FILE.exists() else ''

# Basic helper to save html safely
def save_html(html_text: str, prefix: str = 'chart') -> str:
    slug = hashlib.sha1(html_text.encode('utf-8')).hexdigest()[:8]
    ts = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
    filename = f"{prefix}_{ts}_{slug}.html"
    path = OUTDIR / filename
    with open(path, 'wb') as f:
        data = html_text.encode('utf-8')
        f.write(data)
        f.flush()
        try:
            os.fsync(f.fileno())
        except Exception:
            pass
    return str(path)

# D3 templates
BASE_HTML = """<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>
<title>{title}</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<style>
    body{font-family:Inter,Segoe UI,Arial,sans-serif;margin:20px;background:#f6f7fb;color:#111}
    .container{max-width:1100px;margin:0 auto;background:#fff;padding:20px;border-radius:8px;box-shadow:0 6px 30px rgba(20,30,60,0.08)}
    h2{margin:0 0 12px 0;font-size:18px}
    .viz{width:100%;height:520px}
    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .legend-item{display:flex;align-items:center;gap:8px;font-size:13px}
    .sw{width:14px;height:14px;border-radius:3px}
</style>
</head>
<body>
<div class='container'>
<h2>{title}</h2>
<div id='viz' class='viz'></div>
<div id='legend' class='legend' aria-hidden='false'></div>
<div style='margin-top:8px;color:#666;font-size:13px'>Generated by local D3 MCP server</div>
</div>
<script src='https://d3js.org/d3.v7.min.js'></script>
<script>
{script}
</script>
</body>
</html>
"""

# Utility: safe JSON -> JS variable
def to_js_var(obj, varname='data'):
    j = json.dumps(obj, ensure_ascii=False)
    # escape special </ to avoid HTML issues
    j = j.replace('</', '<\/')
    return f"const {varname} = {j};\n"

# Chart scripts implementations
def script_line(data_var='data', opts=None):
    # data: {labels:[], datasets:[{label,data:[]}]}
    tpl = """
(function(){
const margin = {top:20,right:24,bottom:40,left:50};
const container = d3.select('#viz');
const rect = container.node().getBoundingClientRect();
const rectWidth = rect.width || container.node().clientWidth || document.documentElement.clientWidth || window.innerWidth || 800;
const rectHeight = rect.height || container.node().clientHeight || document.documentElement.clientHeight || window.innerHeight || 520;
const width = Math.max(300, rectWidth) - margin.left - margin.right;
const height = Math.max(200, rectHeight) - margin.top - margin.bottom;
const svg = container.append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom)
  .append('g').attr('transform', `translate(${margin.left},${margin.top})`);
const labels = __DATA_VAR__.labels || [];
const datasets = __DATA_VAR__.datasets || [];
const x = d3.scalePoint().domain(labels).range([0,width]);
const y = d3.scaleLinear().range([height,0]);
let allValues = [];
datasets.forEach(d=>allValues = allValues.concat(d.data));
y.domain([0, d3.max(allValues) || 0]);
const line = d3.line().x((d,i)=>x(labels[i])).y(d=>y(d)).curve(d3.curveMonotoneX);
svg.append('g').attr('transform',`translate(0,${height})`).call(d3.axisBottom(x)).selectAll('text').style('font-size','12px');
svg.append('g').call(d3.axisLeft(y)).selectAll('text').style('font-size','12px');
datasets.forEach(function(ds, idx){
   const color = ds.backgroundColor || ds.borderColor || d3.schemeTableau10[idx%10];
   svg.append('path').datum(ds.data).attr('fill','none').attr('stroke',color).attr('stroke-width',2).attr('d',line);
   svg.selectAll('.dot'+idx).data(ds.data).enter().append('circle').attr('class','dot'+idx).attr('cx',(d,i)=>x(labels[i])).attr('cy',d=>y(d)).attr('r',3).attr('fill',color).attr('stroke','#fff').attr('stroke-width',1);
   // legend
   d3.select('#legend').append('div').attr('class','legend-item').html(`<div class='sw' style='background:${color}'></div><div>${ds.label}</div>`);
});
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)

def script_bar(data_var='data', stacked=False):
    tpl = """
(function(){
const container = d3.select('#viz');
const rect = container.node().getBoundingClientRect();
const margin = {top:20,right:20,bottom:80,left:60};
const rectWidth = rect.width || container.node().clientWidth || document.documentElement.clientWidth || window.innerWidth || 800;
const rectHeight = rect.height || container.node().clientHeight || document.documentElement.clientHeight || window.innerHeight || 520;
const width = Math.max(300, rectWidth) - margin.left - margin.right;
const height = Math.max(200, rectHeight) - margin.top - margin.bottom;
const svg = container.append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom)
  .append('g').attr('transform', `translate(${margin.left},${margin.top})`);
const labels = __DATA_VAR__.labels || [];
const datasets = __DATA_VAR__.datasets || [];
const x0 = d3.scaleBand().domain(labels).range([0,width]).padding(0.2);
const x1 = d3.scaleBand().padding(0.05);
const y = d3.scaleLinear().range([height,0]);
if(__STACKED__){
  // stacked: compute stacks
  const series = d3.stack().keys(d3.range(datasets.length))(labels.map((l,i)=>datasets.map(ds=>ds.data[i]||0)));
  y.domain([0,d3.max(series, s=>d3.max(s, d=>d[1]))||0]);
  x1.domain(d3.range(datasets.length)).range([0,x0.bandwidth()]);
  svg.append('g').attr('transform',`translate(0,${height})`).call(d3.axisBottom(x0)).selectAll('text').attr('transform','rotate(-40)').style('text-anchor','end');
  svg.append('g').call(d3.axisLeft(y));
  const colors = datasets.map((d,i)=>d.backgroundColor||d.borderColor||d3.schemeTableau10[i%10]);
  const groups = svg.selectAll('g.layer').data(series).enter().append('g').attr('class','layer').attr('fill',(d,i)=>colors[i]);
  groups.selectAll('rect').data(d=>d).enter().append('rect').attr('x',(d,i)=>x0(labels[i])).attr('y',d=>y(d[1])).attr('height',d=>y(d[0])-y(d[1])).attr('width',x0.bandwidth());
  datasets.forEach((ds,i)=>{ d3.select('#legend').append('div').attr('class','legend-item').html(`<div class='sw' style='background:${colors[i]}'></div><div>${ds.label}</div>`); });
} else {
  x1.domain(d3.range(datasets.length)).range([0,x0.bandwidth()]);
  const maxv = d3.max(datasets, ds=>d3.max(ds.data||[]))||0; y.domain([0,maxv]);
  svg.append('g').attr('transform',`translate(0,${height})`).call(d3.axisBottom(x0)).selectAll('text').attr('transform','rotate(-40)').style('text-anchor','end');
  svg.append('g').call(d3.axisLeft(y));
  const barGroups = svg.selectAll('g.bar-group').data(labels).enter().append('g').attr('transform',d=>`translate(${x0(d)},0)`);
  barGroups.selectAll('rect').data((d,i)=>datasets.map(ds=>({key:ds.label,value:ds.data[i]||0, color:ds.backgroundColor||ds.borderColor}))).enter().append('rect')
    .attr('x',(d,i)=>x1(i)).attr('y',d=>y(d.value)).attr('width',x1.bandwidth()).attr('height',d=>height-y(d.value)).attr('fill',d=>d.color||'#777');
  datasets.forEach((ds,i)=>{ d3.select('#legend').append('div').attr('class','legend-item').html(`<div class='sw' style='background:${ds.backgroundColor||ds.borderColor||d3.schemeTableau10[i%10]}'></div><div>${ds.label}</div>`); });
}
})();
"""
    return tpl.replace('__DATA_VAR__', data_var).replace('__STACKED__', 'true' if stacked else 'false')

def script_pie(data_var='data', donut=False):
    tpl = """
(function(){
const container = d3.select('#viz');
const rect = container.node().getBoundingClientRect();
const rectWidth = rect.width || container.node().clientWidth || document.documentElement.clientWidth || window.innerWidth || 800;
const rectHeight = rect.height || container.node().clientHeight || document.documentElement.clientHeight || window.innerHeight || 520;
const width = Math.min(600, rectWidth);
const height = Math.min(520, rectHeight);
const radius = Math.min(width, height)/2 - 10;
const svg = container.append('svg').attr('width', width).attr('height', height).append('g').attr('transform',`translate(${width/2},${height/2})`);
const labels = __DATA_VAR__.labels || [];
const ds = __DATA_VAR__.datasets && __DATA_VAR__.datasets[0] || {data:[], backgroundColor: []};
const data = (ds.data || []).map((v,i)=>({label: labels[i]||('Seg'+i), value: v||0, color: (ds.backgroundColor && ds.backgroundColor[i]) || ds.borderColor || d3.schemeTableau10[i%10]}));
const pie = d3.pie().value(d=>d.value);
const arc = d3.arc().innerRadius({INNER}) .outerRadius(radius);
const arcs = svg.selectAll('arc').data(pie(data)).enter().append('g');
arcs.append('path').attr('d',arc).attr('fill',d=>d.data.color).attr('stroke','#fff').attr('stroke-width',1);
arcs.append('title').text(d=>d.data.label+': '+d.data.value);
// legends
const legend = d3.select('#legend');
data.forEach(d=>{ legend.append('div').attr('class','legend-item').html(`<div class='sw' style='background:${d.color}'></div><div>${d.label} — ${d.value}</div>`); });
})();
"""
    inner = 'radius*0.5' if donut else '0'
    return tpl.replace('__DATA_VAR__', data_var).replace('{INNER}', inner)


def script_bubble(data_var='data'):
        # Expects payload: { datasets: [ { label: 'series', data: [ {x:.., y:.., r:..}, ... ], backgroundColor: [] } ] }
        tpl = """
(function(){
const container = d3.select('#viz');
const rect = container.node().getBoundingClientRect();
const width = Math.max(300, rect.width || container.node().clientWidth || window.innerWidth || 800);
const height = Math.max(300, rect.height || container.node().clientHeight || window.innerHeight || 520);
const svg = container.append('svg').attr('width', width).attr('height', height).append('g').attr('transform','translate(40,20)');
const payload = __DATA_VAR__ || {};
const datasets = payload.datasets || [];
if(!datasets.length){ container.append('div').text('No bubble data'); return; }
const points = datasets[0].data || [];
// compute scales
const xs = points.map(d=>+d.x||0), ys = points.map(d=>+d.y||0), rs = points.map(d=>+d.r||0);
const xScale = d3.scaleLinear().domain([d3.min(xs)||0, d3.max(xs)||1]).range([0, width-120]);
const yScale = d3.scaleLinear().domain([d3.min(ys)||0, d3.max(ys)||1]).range([height-80, 0]);
const rScale = d3.scaleSqrt().domain([d3.min(rs)||0, d3.max(rs)||1]).range([4, 40]);
// axes
const xAxis = d3.axisBottom(xScale).ticks(6);
const yAxis = d3.axisLeft(yScale).ticks(6);
svg.append('g').attr('transform',`translate(0,${height-80})`).call(xAxis);
svg.append('g').call(yAxis);
// points
const color = (datasets[0].backgroundColor && datasets[0].backgroundColor[0]) || '#1f77b4';
svg.selectAll('circle').data(points).enter().append('circle')
    .attr('cx',d=>xScale(+d.x||0))
    .attr('cy',d=>yScale(+d.y||0))
    .attr('r',d=>rScale(+d.r||0))
    .attr('fill', (d,i)=> (datasets[0].backgroundColor && datasets[0].backgroundColor[i]) || color)
    .attr('stroke','#fff').attr('stroke-width',1).attr('opacity',0.9)
    .on('mouseover', function(event,d){ const tip = d3.select('body').append('div').attr('id','tmpTip').style('position','absolute').style('padding','6px 8px').style('background','#222').style('color','#fff').style('border-radius','6px').style('pointer-events','none'); tip.html((d.label?d.label+'<br/>':'')+'x:'+d.x+' y:'+d.y+' size:'+d.r); })
    .on('mousemove', function(event){ d3.select('#tmpTip').style('left',(event.pageX+12)+'px').style('top',(event.pageY+12)+'px'); })
    .on('mouseout', function(){ d3.select('#tmpTip').remove(); });
// legend
d3.select('#legend').append('div').attr('class','legend-item').html(`<div class='sw' style='background:${color}'></div><div>${datasets[0].label||'series'}</div>`);
})();
"""
        return tpl.replace('__DATA_VAR__', data_var)


def script_heatmap(data_var='data'):
        # Expects payload: { xLabels:[], yLabels:[], values: [[...]] } where values[y][x]
        tpl = """
(function(){
const container = d3.select('#viz');
const payload = __DATA_VAR__ || {};
const xLabels = payload.xLabels || payload.labels || [];
const yLabels = payload.yLabels || payload.labelsY || [];
const values = payload.values || payload.matrix || payload.data || [];
if(!xLabels.length || !yLabels.length || !values.length){ container.append('div').text('No heatmap data (expect xLabels,yLabels,values matrix)'); return; }
const margin = {top:20,right:20,bottom:80,left:80};
const rect = container.node().getBoundingClientRect();
const width = Math.max(320, rect.width || container.node().clientWidth || window.innerWidth) - margin.left - margin.right;
const height = Math.max(240, rect.height || container.node().clientHeight || window.innerHeight) - margin.top - margin.bottom;
const gridWidth = width / xLabels.length;
const gridHeight = height / yLabels.length;
const svg = container.append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom)
    .append('g').attr('transform',`translate(${margin.left},${margin.top})`);
// color scale
const flat = [].concat.apply([], values.map(r=>r.map(v=>+v||0)));
const minV = d3.min(flat), maxV = d3.max(flat);
const color = d3.scaleSequential(d3.interpolateYlOrRd).domain([minV||0, maxV||1]);
// cells
for(var yi=0;yi<yLabels.length;yi++){
    for(var xi=0;xi<xLabels.length;xi++){
        var v = values[yi] && values[yi][xi] != null ? values[yi][xi] : 0;
        svg.append('rect').attr('x', xi*gridWidth).attr('y', yi*gridHeight).attr('width', Math.max(1, gridWidth-1)).attr('height', Math.max(1, gridHeight-1)).style('fill', color(+v)).style('stroke','#fff').style('stroke-width',0.3)
            .on('mouseover', (function(xi,yi,v){ return function(event){ var tip = d3.select('body').append('div').attr('id','tmpTip').style('position','absolute').style('padding','6px 8px').style('background','#222').style('color','#fff').style('border-radius','6px').style('pointer-events','none'); tip.html(xLabels[xi] + ' / ' + yLabels[yi] + ': ' + v); }; })(xi,yi,v))
            .on('mousemove', function(event){ d3.select('#tmpTip').style('left',(event.pageX+12)+'px').style('top',(event.pageY+12)+'px'); })
            .on('mouseout', function(){ d3.select('#tmpTip').remove(); });
    }
}
// axes labels
const xg = svg.append('g').attr('transform',`translate(0,${height})`);
xg.selectAll('text').data(xLabels).enter().append('text').attr('x', (d,i)=>i*gridWidth + gridWidth/2).attr('y',12).attr('text-anchor','middle').text(d=>d).style('font-size','11px');
const yg = svg.append('g');
yg.selectAll('text').data(yLabels).enter().append('text').attr('x', -8).attr('y', (d,i)=>i*gridHeight + gridHeight/2).attr('text-anchor','end').text(d=>d).style('font-size','11px');
// legend swatches: simple gradient
var legend = d3.select('#legend'); legend.append('div').text('Heatmap scale');
})();
"""
        return tpl.replace('__DATA_VAR__', data_var)


def script_packed(data_var='data'):
    # Expects payload: { items: [ {id: 'A', label: 'A label', value: 123, color: '#...' }, ... ] }
    tpl = """
(function(){
const container = d3.select('#viz');
const payload = __DATA_VAR__ || {};
const items = payload.items || payload.data || [];
if(!items || !items.length){ container.append('div').text('No packed data (expect items: [{id,label,value,color}])'); return; }
// build hierarchy root
const root = { name: 'root', children: items.map(i=>({ name: i.id || i.label || i.name || String(i), value: +i.value || 0, color: i.color })) };
const rect = container.node().getBoundingClientRect();
const width = Math.max(320, rect.width || container.node().clientWidth || window.innerWidth) ;
const height = Math.max(320, rect.height || container.node().clientHeight || window.innerHeight) ;
const svg = container.append('svg').attr('width', width).attr('height', height).append('g').attr('transform','translate(0,0)');
const pack = d3.pack().size([width, height]).padding(4);
const hierarchy = d3.hierarchy(root).sum(d=>d.value||0).sort((a,b)=>b.value - a.value);
pack(hierarchy);
const node = svg.selectAll('g.node').data(hierarchy.leaves()).enter().append('g').attr('transform', d=>`translate(${d.x},${d.y})`);
node.append('circle').attr('r', d=>d.r).attr('fill', (d,i)=> d.data.color || d3.schemeTableau10[i % 10]).attr('stroke','#fff').attr('stroke-width',1);
node.append('title').text(d=>d.data.name + ': ' + (d.data.value||0));
node.append('text').attr('dy', '.3em').style('text-anchor','middle').style('font-size','11px').text(d=>d.data.name.length > 12 ? d.data.name.slice(0,10)+'..' : d.data.name);
// legend simple
const legend = d3.select('#legend'); items.slice(0,8).forEach(function(it,i){ legend.append('div').attr('class','legend-item').html(`<div class='sw' style='background:${it.color||d3.schemeTableau10[i%10]}'></div><div>${it.label||it.id||it.name||''} — ${it.value||0}</div>`); });
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_histogram(data_var='data'):
    # Expects payload: {values: [10,20,30,...], bins: 10}
    tpl = """
(function(){
const container = d3.select('#viz'); const payload = __DATA_VAR__||{};
const values = payload.values || payload.data || [];
if(!values.length){ container.append('div').text('No histogram data (expect values: [])'); return; }
const bins = payload.bins || 10;
const rect = container.node().getBoundingClientRect(); const width = Math.max(320, rect.width)-40; const height = Math.max(240, rect.height)-40;
const svg = container.append('svg').attr('width', width).attr('height', height).append('g').attr('transform','translate(20,10)');
const x = d3.scaleLinear().domain(d3.extent(values)).range([0, width-60]);
const histogram = d3.bin().domain(x.domain()).thresholds(bins);
const binsData = histogram(values);
const y = d3.scaleLinear().domain([0, d3.max(binsData, d=>d.length)||1]).range([height-60,0]);
svg.selectAll('rect').data(binsData).enter().append('rect').attr('x', d=>x(d.x0)).attr('y', d=>y(d.length)).attr('width', d=>Math.max(1, x(d.x1)-x(d.x0)-1)).attr('height', d=>height-60 - y(d.length)).attr('fill','#69b3a2');
svg.append('g').attr('transform',`translate(0,${height-60})`).call(d3.axisBottom(x));
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_horizontal_bar(data_var='data'):
    # Expects payload: {labels:[], values:[]}
    tpl = """
(function(){
const container = d3.select('#viz'); const payload = __DATA_VAR__||{}; const labels = payload.labels||[]; const vals = payload.values||payload.data||[];
if(!labels.length){ container.append('div').text('No horizontal bar data'); return; }
const rect = container.node().getBoundingClientRect(); const width = Math.max(320, rect.width)-40; const height = Math.max(240, rect.height)-40;
const svg = container.append('svg').attr('width', width).attr('height', height).append('g').attr('transform','translate(100,10)');
const y = d3.scaleBand().domain(labels).range([0, height-60]).padding(0.1);
const x = d3.scaleLinear().domain([0, d3.max(vals)||0]).range([0, width-160]);
svg.selectAll('rect').data(labels).enter().append('rect').attr('y', d=>y(d)).attr('x',0).attr('height', y.bandwidth()).attr('width', (d,i)=>x(vals[i]||0)).attr('fill','#4C78A8');
svg.append('g').call(d3.axisLeft(y));
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_grouped_bar(data_var='data'):
    # Expects payload: {labels:[], datasets:[{label:'A', data:[]}, ...]}
    tpl = """
(function(){
const payload = __DATA_VAR__||{}; const labels = payload.labels||[]; const datasets = payload.datasets||[]; if(!labels.length||!datasets.length){ d3.select('#viz').append('div').text('No grouped bar data'); return; }
const rect = d3.select('#viz').node().getBoundingClientRect(); const width = Math.max(320, rect.width)-60; const height = Math.max(240, rect.height)-60;
const svg = d3.select('#viz').append('svg').attr('width', width).attr('height', height).append('g').attr('transform','translate(40,20)');
const x0 = d3.scaleBand().domain(labels).range([0, width-80]).padding(0.2);
const x1 = d3.scaleBand().domain(d3.range(datasets.length)).range([0, x0.bandwidth()]).padding(0.05);
const y = d3.scaleLinear().domain([0, d3.max(datasets, ds=>d3.max(ds.data||[]))||0]).range([height-80,0]);
const colors = datasets.map((d,i)=>d.backgroundColor||d.borderColor||d3.schemeTableau10[i%10]);
const groups = svg.selectAll('g').data(labels).enter().append('g').attr('transform', d=>`translate(${x0(d)},0)`);
groups.selectAll('rect').data((d,i)=>datasets.map(ds=>({v:ds.data[i]||0, color: ds.backgroundColor||ds.borderColor}))).enter().append('rect').attr('x',(d,i)=>x1(i)).attr('y',d=>y(d.v)).attr('width',x1.bandwidth()).attr('height',d=>height-80 - y(d.v)).attr('fill',d=>d.color||'#777');
svg.append('g').attr('transform',`translate(0,${height-80})`).call(d3.axisBottom(x0));
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_scatter(data_var='data'):
    # Expects payload: [{x:.., y:.., label:?}, ...] or {points:[...]}
    tpl = """
(function(){
const container = d3.select('#viz'); const payload = __DATA_VAR__||{}; const pts = payload.points || payload.data || [];
if(!pts.length){ container.append('div').text('No scatter data'); return; }
const rect = container.node().getBoundingClientRect(); const width = Math.max(320, rect.width)-40; const height = Math.max(240, rect.height)-40;
const svg = container.append('svg').attr('width', width).attr('height', height).append('g').attr('transform','translate(40,20)');
const x = d3.scaleLinear().domain(d3.extent(pts, d=>+d.x||0)).range([0, width-80]); const y = d3.scaleLinear().domain(d3.extent(pts, d=>+d.y||0)).range([height-80,0]);
svg.append('g').attr('transform',`translate(0,${height-80})`).call(d3.axisBottom(x)); svg.append('g').call(d3.axisLeft(y));
svg.selectAll('circle').data(pts).enter().append('circle').attr('cx',d=>x(+d.x||0)).attr('cy',d=>y(+d.y||0)).attr('r', d=>+d.r||4).attr('fill', d=>d.color||'#1f77b4').attr('opacity',0.9);
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_treemap_placeholder(data_var='data'):
    # Expects hierarchical payload like {name:'root', children:[{name:'A', value:10}, ...]}
    tpl = """
(function(){
const container = d3.select('#viz'); const payload = __DATA_VAR__||{}; const root = payload;
if(!root || !root.children){ container.append('div').text('Treemap expects hierarchical data with children'); return; }
const rect = container.node().getBoundingClientRect(); const width = Math.max(320, rect.width)-40; const height = Math.max(320, rect.height)-40;
const svg = container.append('svg').attr('width', width).attr('height', height);
var hierarchy = d3.hierarchy(root).sum(d=>d.value||0);
d3.treemap().size([width,height]).padding(2)(hierarchy);
var nodes = svg.selectAll('g').data(hierarchy.leaves()).enter().append('g').attr('transform', d=>'translate('+d.x0+','+d.y0+')');
nodes.append('rect').attr('width', d=>d.x1-d.x0).attr('height', d=>d.y1-d.y0).attr('fill', (d,i)=>d.data.color||d3.schemeTableau10[i%10]);
nodes.append('text').attr('x',4).attr('y',14).text(d=>d.data.name||'');
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_tree(data_var='data'):
    # Expects hierarchical payload: {name:'root', children:[...]} -> renders a simple dendrogram
    tpl = """
(function(){
const data = __DATA_VAR__ || {};
if(!data || !data.children){ d3.select('#viz').append('div').text('Tree expects hierarchical data'); return; }
const width = Math.max(320, document.getElementById('viz').clientWidth||400), height = Math.max(320, document.getElementById('viz').clientHeight||400);
const root = d3.hierarchy(data);
const tree = d3.tree().size([height-40, width-160]); tree(root);
const svg = d3.select('#viz').append('svg').attr('width', width).attr('height', height).append('g').attr('transform','translate(80,20)');
svg.selectAll('line').data(root.links()).enter().append('line').attr('x1',d=>d.source.y).attr('y1',d=>d.source.x).attr('x2',d=>d.target.y).attr('y2',d=>d.target.x).attr('stroke','#999');
svg.selectAll('text').data(root.descendants()).enter().append('text').attr('x',d=>d.y).attr('y',d=>d.x).text(d=>d.data.name||'').attr('font-size',10);
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_force(data_var='data'):
    # Expects payload: {nodes:[{id:...}], links:[{source:..., target:...}]}
    tpl = """
(function(){
const payload = __DATA_VAR__||{}; const nodes = payload.nodes||[]; const links = payload.links||[]; if(!nodes.length){ d3.select('#viz').append('div').text('No force graph nodes'); return; }
const width = Math.max(320, document.getElementById('viz').clientWidth||600), height = Math.max(320, document.getElementById('viz').clientHeight||400);
const svg = d3.select('#viz').append('svg').attr('width', width).attr('height', height);
const sim = d3.forceSimulation(nodes).force('charge', d3.forceManyBody().strength(-200)).force('link', d3.forceLink(links).id(d=>d.id).distance(60)).force('center', d3.forceCenter(width/2,height/2));
const link = svg.append('g').selectAll('line').data(links).enter().append('line').attr('stroke','#999');
const node = svg.append('g').selectAll('circle').data(nodes).enter().append('circle').attr('r',6).attr('fill','#1f77b4');
sim.on('tick', ()=>{ link.attr('x1',d=>d.source.x).attr('y1',d=>d.source.y).attr('x2',d=>d.target.x).attr('y2',d=>d.target.y); node.attr('cx',d=>d.x).attr('cy',d=>d.y); });
})();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_chord_placeholder(data_var='data'):
    # Placeholder: expects adjacency matrix; implementing full chord diagram is left as an exercise
    tpl = """
(function(){ d3.select('#viz').append('div').text('Chord diagram placeholder - requires adjacency matrix payload'); })();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_sankey_placeholder(data_var='data'):
    tpl = """
(function(){ d3.select('#viz').append('div').text('Sankey placeholder - requires d3-sankey plugin and proper payload'); })();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_choropleth_placeholder(data_var='data'):
    tpl = """
(function(){ d3.select('#viz').append('div').text('Choropleth placeholder - requires GeoJSON + value mapping'); })();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_radar_placeholder(data_var='data'):
    tpl = """
(function(){ d3.select('#viz').append('div').text('Radar chart placeholder - consider using d3.lineRadial'); })();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_calendar_heatmap_placeholder(data_var='data'):
    tpl = """
(function(){ d3.select('#viz').append('div').text('Calendar heatmap placeholder - expects date,value array'); })();
"""
    return tpl.replace('__DATA_VAR__', data_var)


def script_parallel_coords_placeholder(data_var='data'):
    tpl = """
(function(){ d3.select('#viz').append('div').text('Parallel coordinates placeholder - expects array of records with same keys'); })();
"""
    return tpl.replace('__DATA_VAR__', data_var)


# Main request handler
def render_using_script(script_fn, args, title=None, prefix='chart'):
    """Render payload using a raw script function (script_fn returns JS code)."""
    title_text = None
    payload = None
    if isinstance(args, dict):
        title_text = args.get('title') or args.get('chart_title') or args.get('title_text')
        payload = args.get('data') or args.get('payload') or args.get('dataset') or args
    else:
        payload = args
    if payload is None:
        payload = {}
    title_text = title_text or title or 'D3 Chart'
    script = to_js_var(payload, 'data') + script_fn('data')
    html_text = BASE_HTML.replace('{title}', html.escape(title_text)).replace('{script}', script)
    path = save_html(html_text, prefix=prefix)
    return {'status': 'ok', 'path': path, 'html': html_text}


TOOLS = {
    'line': lambda args: handle_template(args, chart_type='line'),
    'multi_line': lambda args: handle_template(args, chart_type='line'),
    'bar': lambda args: handle_template(args, chart_type='bar'),
    'multi_bar': lambda args: handle_template(args, chart_type='bar'),
    'stacked_bar': lambda args: handle_template(args, chart_type='bar', stacked=True),
    'pie': lambda args: handle_template(args, chart_type='pie'),
    'donut': lambda args: handle_template(args, chart_type='donut'),
    'bubble': lambda args: handle_template(args, chart_type='bubble'),
    'heatmap': lambda args: handle_template(args, chart_type='heatmap'),
    'packed': lambda args: handle_template(args, chart_type='packed'),
    'histogram': lambda args: render_using_script(script_histogram, args, prefix='histogram'),
    'horizontal_bar': lambda args: render_using_script(script_horizontal_bar, args, prefix='hbar'),
    'grouped_bar': lambda args: render_using_script(script_grouped_bar, args, prefix='grouped_bar'),
    'scatter': lambda args: render_using_script(script_scatter, args, prefix='scatter'),
    'treemap': lambda args: render_using_script(script_treemap_placeholder, args, prefix='treemap'),
    'tree': lambda args: render_using_script(script_tree, args, prefix='tree'),
    'force': lambda args: render_using_script(script_force, args, prefix='force'),
    'chord': lambda args: render_using_script(script_chord_placeholder, args, prefix='chord'),
    'sankey': lambda args: render_using_script(script_sankey_placeholder, args, prefix='sankey'),
    'choropleth': lambda args: render_using_script(script_choropleth_placeholder, args, prefix='choropleth'),
    'radar': lambda args: render_using_script(script_radar_placeholder, args, prefix='radar'),
    'calendar_heatmap': lambda args: render_using_script(script_calendar_heatmap_placeholder, args, prefix='calendar_heatmap'),
    'parallel_coords': lambda args: render_using_script(script_parallel_coords_placeholder, args, prefix='parallel_coords'),
    'render_from_dataset': lambda args: render_from_dataset_tool(args),
    'merge_timeseries': lambda args: merge_timeseries_tool(args),
}


def merge_timeseries_tool(args: dict):
    """Merge multiple timeseries (list of series or dict of plan results) into normalized {labels, datasets}.
    Expected input shapes:
      - {'series': [{'label':'s1','labels':[...],'data':[...], 'color':'#...' }, ...]}
      - {'items': [{'id':'s1','result':[{'month':'2025-01','value':1}, ...]}, ...]} where inner records have a time-like key
      - Or a dict mapping keys to lists of records: {'s1': [...], 's2': [...]} where each list has objects with a time label
    Returns: {'status':'ok','merged': {'labels': [...], 'datasets': [...]}}
    """
    try:
        # normalize various incoming shapes
        series_input = []
        if not args:
            return {'status':'error','message':'no_args'}
        # direct 'series' list
        if isinstance(args, dict) and 'series' in args and isinstance(args['series'], list):
            series_input = args['series']
        # plan-like items with 'result' lists
        elif isinstance(args, dict) and 'items' in args and isinstance(args['items'], list):
            for it in args['items']:
                sid = it.get('id') or it.get('name') or 'series'
                recs = it.get('result') or it.get('records') or it.get('data') or []
                series_input.append({'label': sid, 'records': recs})
        # mapping of keys to list-of-records
        elif isinstance(args, dict) and all(isinstance(v, list) for v in args.values()):
            for k, v in args.items():
                series_input.append({'label': k, 'records': v})
        else:
            # try to see if args itself is a list of series-like dicts
            if isinstance(args, list):
                for s in args:
                    if isinstance(s, dict):
                        series_input.append(s)

        # helper to detect label key and numeric key inside records
        def detect_keys(records):
            if not records or not isinstance(records, list):
                return (None, None)
            sample = records[0]
            if not isinstance(sample, dict):
                return (None, None)
            label_key = None
            numeric_key = None
            for k in sample.keys():
                lk = k.lower()
                if any(x in lk for x in ('month', 'date', 'period', 'time', 'week')):
                    label_key = k
                    break
            if not label_key:
                # fallback to common names
                for k in sample.keys():
                    if k.lower() in ('label', 'name', 'period'):
                        label_key = k; break
            for k, v in sample.items():
                if k == label_key:
                    continue
                if isinstance(v, (int, float)) or (isinstance(v, str) and re.match(r'^[\d,\.\-\s]+$', v.strip())):
                    numeric_key = k
                    break
            return (label_key, numeric_key)

        # Build a mapping of label -> index by union of all labels
        all_labels_set = set()
        prepared = []
        for s in series_input:
            lbl = s.get('label') or s.get('id') or s.get('name') or 'series'
            records = s.get('records') or s.get('data') or s.get('values') or s.get('points') or []
            if isinstance(records, list) and records and isinstance(records[0], dict):
                lk, nk = detect_keys(records)
                if lk and nk:
                    labels = [str(r.get(lk, '') ) for r in records]
                    vals = []
                    for r in records:
                        v = r.get(nk, 0)
                        try:
                            if isinstance(v, str):
                                v = float(re.sub(r'[^0-9.\-\.]', '', v) or 0)
                        except Exception:
                            try: v = float(v)
                            except Exception: v = 0
                        vals.append(float(v or 0))
                    for L in labels:
                        all_labels_set.add(L)
                    prepared.append({'label': lbl, 'labels': labels, 'data': vals, 'color': s.get('color') or s.get('backgroundColor') or s.get('borderColor')})
                else:
                    # skip unknown shape
                    continue
            elif isinstance(records, list) and records and not isinstance(records[0], dict):
                # positional series with implicit labels
                idx_labels = [str(i) for i in range(len(records))]
                for L in idx_labels:
                    all_labels_set.add(L)
                prepared.append({'label': lbl, 'labels': idx_labels, 'data': [float(v or 0) for v in records], 'color': s.get('color') or s.get('backgroundColor') or s.get('borderColor')})

        if not prepared:
            return {'status':'error','message':'no_series_parsable'}

        # Build unified ordered labels (sort months like YYYY-MM or lexicographically)
        def sort_labels(labels_list):
            # attempt to sort by YYYY-MM pattern
            try:
                if all(re.match(r'^\d{4}-\d{2}$', l) for l in labels_list):
                    return sorted(labels_list)
            except Exception:
                pass
            # fallback lexicographic
            return sorted(labels_list)

        all_labels = sort_labels(list(all_labels_set))

        # Build aligned datasets filling missing values with 0
        datasets = []
        palette = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b']
        for i, s in enumerate(prepared):
            lbl = s['label']
            mapping = {l: v for l, v in zip(s['labels'], s['data'])}
            aligned = [float(mapping.get(L, 0) or 0) for L in all_labels]
            color = s.get('color') or palette[i % len(palette)]
            datasets.append({'label': lbl, 'data': aligned, 'borderColor': color, 'backgroundColor': color, 'fill': False})

        merged = {'labels': all_labels, 'datasets': datasets}
        return {'status':'ok','merged': merged}
    except Exception as e:
        tb = traceback.format_exc()
        return {'status':'error','message':'merge_failed','error': str(e), 'trace': tb}

def handle_template(args, chart_type='line', stacked=False):
    # args may contain title and data. Data expected normalized: {labels:[], datasets:[{label,data:[], backgroundColor:[]}]}
    title = args.get('title') or args.get('chart_title') or 'D3 Chart'
    payload = args.get('data') or args.get('dataset') or args.get('payload') or {}
    # if payload is dict with 'result' key, try to normalize
    if isinstance(payload, dict) and 'result' in payload and isinstance(payload['result'], list):
        # attempt to normalize list of dicts into labels + datasets if possible
        recs = payload['result']
        # primitive normalization: if recs are objects with 'project' and 'planned_cost' keys, make labels and one dataset
        if recs and isinstance(recs[0], dict):
            sample = recs[0]
            # choose category key heuristically
            cat = None
            numeric = None
            for k in sample.keys():
                lk = k.lower()
                if any(x in lk for x in ('project','name','title')) and isinstance(sample[k], str):
                    cat = k; break
            for k in sample.keys():
                if k==cat: continue
                if isinstance(sample[k], (int,float)) or (isinstance(sample[k], str) and sample[k].strip().replace('.','',1).replace(',','').lstrip('-').isdigit()):
                    numeric = k; break
            if cat and numeric:
                labels = [str(r.get(cat,'')) for r in recs]
                values = []
                for r in recs:
                    try: v = r.get(numeric,0)
                    except: v = 0
                    try: values.append(float(str(v).replace(',','')))
                    except: values.append(0)
                payload = {'labels': labels, 'datasets':[{'label': numeric, 'data': values}]}
    # If the caller explicitly requested a D3-only chart, handle directly before
    # enforcing the normalized labels/datasets shape. This lets callers provide
    # payloads like {'items': [...]} for packed charts or raw datasets for bubble/heatmap.
    ct = chart_type.lower() if isinstance(chart_type, str) else None
    # explicit packed/proportional
    if ct in ('packed', 'pack', 'proportional') or (isinstance(payload, dict) and 'items' in payload):
        script = to_js_var(payload, 'data') + script_packed('data')
        html_text = BASE_HTML.replace('{title}', html.escape(title)).replace('{script}', script)
        path = save_html(html_text, prefix='packed')
        return {'status':'ok', 'path': path, 'html': html_text}
    # explicit bubble
    if ct == 'bubble':
        script = to_js_var(payload, 'data') + script_bubble('data')
        html_text = BASE_HTML.replace('{title}', html.escape(title)).replace('{script}', script)
        path = save_html(html_text, prefix='bubble')
        return {'status':'ok', 'path': path, 'html': html_text}
    # explicit heatmap
    if ct == 'heatmap':
        script = to_js_var(payload, 'data') + script_heatmap('data')
        html_text = BASE_HTML.replace('{title}', html.escape(title)).replace('{script}', script)
        path = save_html(html_text, prefix='heatmap')
        return {'status':'ok', 'path': path, 'html': html_text}

    # fallback ensure payload has labels/datasets
    labels = payload.get('labels') if isinstance(payload, dict) else None
    datasets = payload.get('datasets') if isinstance(payload, dict) else None
    if not labels or not datasets:
        # attempt to accept shorthand data like {'labels':[], 'values':[]}
        if isinstance(payload, dict) and 'labels' in payload and 'values' in payload:
            labels = payload['labels']
            datasets = [{'label':'Value','data':payload['values']}]
        else:
            # as last resort return an error html (use replace to avoid formatting CSS braces)
            html_text = BASE_HTML.replace('{title}', html.escape(title)).replace('{script}', "console.error('No data provided to render chart')")
            path = save_html(html_text, prefix='error_chart')
            return {'status':'error','message':'no_data','path':path,'html':html_text}
    # select script
    if chart_type=='line':
        script = to_js_var(payload,'data') + script_line('data')
    elif chart_type=='bar' and not stacked:
        script = to_js_var(payload,'data') + script_bar('data', stacked=False)
    elif chart_type=='bar' and stacked:
        script = to_js_var(payload,'data') + script_bar('data', stacked=True)
    elif chart_type=='pie' or chart_type=='donut':
        script = to_js_var(payload,'data') + script_pie('data', donut=(chart_type=='donut'))
    elif chart_type=='bubble':
        script = to_js_var(payload,'data') + script_bubble('data')
    elif chart_type=='heatmap':
        script = to_js_var(payload,'data') + script_heatmap('data')
    elif isinstance(chart_type, str) and chart_type.lower() in ('packed','pack','proportional'):
        script = to_js_var(payload,'data') + script_packed('data')
    else:
        script = to_js_var(payload,'data') + script_line('data')
    # Use simple replace to inject title and script. Avoid str.format because the
    # JavaScript template contains many braces which interfere with Python formatting.
    html_text = BASE_HTML.replace('{title}', html.escape(title)).replace('{script}', script)
    path = save_html(html_text, prefix=chart_type)
    return {'status':'ok','path':path,'html':html_text}


def render_from_dataset_tool(args: dict):
    """Tool to accept a normalized payload or inline dataset and return saved HTML path and html."""
    try:
        payload = None
        # common: caller provides a wrapper: {"data": {...}} or {"payload": {...}} or {"dataset": {...}}
        if isinstance(args, dict) and 'data' in args and isinstance(args['data'], (dict, list)):
            payload = args['data']
        elif isinstance(args, dict) and 'payload' in args and isinstance(args['payload'], (dict, list)):
            payload = args['payload']
        elif isinstance(args, dict) and 'dataset' in args:
            payload = args['dataset']
        # accept when the caller passes the normalized payload at the top-level, e.g. arguments = {labels:[], datasets:[]}
        elif isinstance(args, dict) and 'labels' in args and 'datasets' in args:
            payload = args
        # accept when args is itself a list/dict payload
        elif isinstance(args, (dict, list)) and ('labels' in args if isinstance(args, dict) else False):
            payload = args
        elif isinstance(args, dict) and 'html' in args and isinstance(args['html'], str):
            html_text = args['html']
            path = save_html(html_text, prefix='render')
            return {'status':'ok','path':path,'html':html_text}
        else:
            if isinstance(args, dict):
                for v in args.values():
                    if isinstance(v, str):
                        j = extract_json_from_text(v)
                        if j:
                            payload = j
                            break
        if not payload:
            return {'status':'error','message':'no_payload','details':'No data/payload/html found in arguments'}

        # Honor explicit chart type hint if provided (e.g., 'pie' or 'donut')
        chart_type_hint = None
        if isinstance(args, dict):
            chart_type_hint = args.get('chart_type') or args.get('type') or args.get('chartType')
        # If the caller explicitly asked for a packed/proportional chart, route to handle_template
        if isinstance(chart_type_hint, str) and str(chart_type_hint).strip().lower() in ('packed', 'pack', 'proportional'):
            # Use handle_template which selects the D3 packed template when chart_type='packed'
            html_result = handle_template({'data': payload, 'title': args.get('title') or args.get('chart_title') or 'Chart'}, chart_type='packed')
            return html_result

        # Heuristic: if caller passed a normalized Chart.js-style payload (labels + single numeric dataset)
        # treat it as a proportional-area (packed) candidate and render with D3 pack for proportional circles.
        try:
            if isinstance(payload, dict) and 'labels' in payload and 'datasets' in payload and isinstance(payload['datasets'], list) and len(payload['datasets']) == 1:
                labels = payload.get('labels') or []
                ds = payload['datasets'][0]
                values = ds.get('data') if isinstance(ds.get('data'), list) else None
                if isinstance(labels, list) and isinstance(values, list) and len(labels) == len(values) and len(labels) > 0:
                    # Check that values are numeric (or numeric strings)
                    numeric_ok = True
                    numeric_vals = []
                    for v in values:
                        try:
                            nv = float(v)
                            numeric_vals.append(nv)
                        except Exception:
                            numeric_ok = False
                            break
                    if numeric_ok:
                        # Build items list for packed renderer
                        colors = ds.get('backgroundColor') if isinstance(ds.get('backgroundColor'), list) else None
                        items = []
                        for i, lab in enumerate(labels):
                            item = {'id': lab, 'label': lab, 'value': numeric_vals[i]}
                            if colors and i < len(colors):
                                item['color'] = colors[i]
                            items.append(item)
                        html_result = handle_template({'data': {'items': items}, 'title': args.get('title') or args.get('chart_title') or 'Chart'}, chart_type='packed')
                        return html_result
        except Exception:
            # fall through to default renderer
            pass

        html_text = render_chart_html_from_dataset(payload, title_text=args.get('title') or args.get('chart_title') or 'Chart', chart_type=chart_type_hint)
        path = save_html(html_text, prefix='render')
        return {'status':'ok','path':path,'html':html_text}
    except Exception as e:
        tb = traceback.format_exc()
        return {'status':'error','message':'render_failed','error':str(e),'trace':tb}

# Main loop: read lines from stdin
if __name__ == '__main__':
    for line in sys.stdin:
        line = line.strip()
        if not line:
            continue
        try:
            req = json.loads(line)
        except Exception as e:
            resp = {'status':'error','message':'invalid_json','error':str(e)}
            print(json.dumps(resp), flush=True)
            continue
        tool = req.get('tool') or req.get('name')
        args = req.get('arguments') or req.get('args') or req.get('payload') or {}
        handler = TOOLS.get(tool)
        if not handler:
            resp = {'status':'error','message':'unknown_tool','tool':tool}
            print(json.dumps(resp), flush=True)
            continue
        try:
            result = handler(args)
            print(json.dumps(result), flush=True)
        except Exception as e:
            tb = traceback.format_exc()
            resp = {'status':'error','message':'handler_exception','error':str(e), 'trace': tb}
            print(json.dumps(resp), flush=True)
